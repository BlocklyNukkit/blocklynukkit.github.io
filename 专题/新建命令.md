# 新建命令  

本章节中，将带您了解如何新建一个命令  

## 基本命令

在BlocklyNukkit中，我们使用`manager`基对象中的`createCommand`函数来创建新命令：  
**manager基对象**  

|方法名|参数|返回值|解释|
|-----|-----|-----|----|
|createCommand|String name,String des,String call|void|创建名称为name,描述为des的命令，回调函数的函数名为call|
|createCommand|String name,String des,String call,String per|void|同上，但是仅限有per权限的玩家可用|  

命令的回调函数需要接受两个参数，分别是[命令发出者](https://wiki.blocklynukkit.info/javadoc/cn.nukkit.command.CommandSender.html)和命令的参数，我们通常用`sender`和`args`来接收这两个参数。
[命令发出者](https://wiki.blocklynukkit.info/javadoc/cn.nukkit.command.CommandSender.html)是执行这个命令的事物的信息抽象，它**并不是**命令发出者本身！  
命令发出者可以是玩家、可以是控制台、也可以是远程命令(QQ群互动、某些mc面板)。
关于命令发出者对象的详细信息，点击“[命令发出者](https://wiki.blocklynukkit.info/javadoc/cn.nukkit.command.CommandSender.html)”跳转到javadoc。后面我们会详细讲述。  
命令的参数是一个由字符串组成的数组(python中称列表)，这个数组记录了玩家输入命令主名称后的内容。
每一条命令都由命令前缀、命令名称和命令参数三部分组成。  
命令前缀是指命令开头的`/`，控制台输入时无前缀。  
命令名称是命令的主要标识符，用于区分不同的命令，是每一条命令中第一个空格之前的、命令前缀之后的部分，如果没有空格的话，命令名称就是这条命令前缀之后的剩余部分。  
命令参数是除了上述两项之外剩余内容一个空格分割成的数组。  
举个例子：  
> /gamemode 1 Steve  
> 命令前缀是`/`  
> 命令名称是`gamemode`  
> 命令参数是`"1","Steve"`  

创建一个命令只需要调用`createCommand`即可，其中函数`myCommandCallbak`的名称可以是任意的：
{% capture create %} 
```javascript
function myCommandCallback(sender,args){
    console.log("命令被触发");
}
manager.createCommand("mycommand","我的测试命令","myCommandCallback");
```
---NEWTAB--- 
```python
def myCommandCallback(sender,args):
    logger.info(u"命令被触发")
manager.createCommand(u"mycommand",u"我的测试命令",u"myCommandCallback")
```
---NEWTAB--- 
```lua
function myCommandCallback(sender,args)  
    logger:info("命令被触发")
end
manager:createCommand("mycommand","我的测试命令","myCommandCallback")  
```
---NEWTAB--- 
```php
function myCommandCallback($sender,$args){
    echo "命令被触发"; 
}
$manager->createCommand("mycommand","我的测试命令","myCommandCallback");
```
{% endcapture %}
{% include tab.html tabId="create" tabTitles="JavaScript,Python,Lua,PHP" tabContents=create %}

## 子命令与参数  

注册命令的时候，我们注册的命令不能包含空格，你可能很多情况下会看见类似于`money add xxxxxx`这样的命令，实际上，这是通过判断参数的方式实现的  
我们现在来实现一个包含`first`和`second`两个子命令的命令，并且在输入的命令不符合这两个子命令时发出提示：  

{% capture subcmd %} 
```javascript
function myCommandCallback(sender,args){
    if(args[0]=="first"){
        console.log("第一个子命令");
    }else if(args[0]=="second"){
        console.log("第二个子命令");
    }else{
        console.log("命令格式不对");
    }
}
manager.createCommand("mycommand","我的测试命令","myCommandCallback");
```
---NEWTAB--- 
```python
def myCommandCallback(sender,args):
    if args[0] == u"first":
        logger.info("第一个子命令")
    elif args[0] == u"second":
        logger.info("第二个子命令")
	else:
        logger.info(u"命令格式不对")
manager.createCommand(u"mycommand",u"我的测试命令",u"myCommandCallback")
```
---NEWTAB--- 
```lua
function myCommandCallback(sender,args)  
    if(args[0] == "first") then
        logger:info("第一个子命令")
    elseif(args[0] == "second") then
        logger:info("第二个子命令")
    else
        logger:info("命令格式不对")
    end
end
manager:createCommand("mycommand","我的测试命令","myCommandCallback")  
```
---NEWTAB--- 
```php
function myCommandCallback($sender,$args){
    if(strcmp($args[0],"first") == 0){
        echo "第一个子命令";
    }else if(strcmp($args[0],"second") == 0){
        echo "第二个子命令";
    }else{
        echo "命令格式不对"; 
    }
}
$manager->createCommand("mycommand","我的测试命令","myCommandCallback");
```
{% endcapture %}
{% include tab.html tabId="subcmd" tabTitles="JavaScript,Python,Lua,PHP" tabContents=subcmd %}

## 命令发送者  

之前我们已经提到过了命令发送者，通过这个对象我们可以获知一些输入命令的东西的基本信息。  
在[javadoc](https://wiki.blocklynukkit.info/javadoc/cn.nukkit.command.CommandSender.html)上可以看到，命令发送者有如下几个常用的函数：  

|函数名|参数|返回值|解释|
|-----|-----|-----|----|
|isPlayer|void|boolean|命令是否是玩家发出的|
|isOp|void|boolean|执行命令的人是否有op权限(控制台执行算有)|
|sendMessage|String message|void|向命令发送者返回信息|
|getName|void|String|获取命令发送者的名称(控制台发出恒为CONSOLE)|

通过这些函数，我们可以对轻松地返回命令执行信息到执行命令的玩家，而不是无脑把信息都输出到控制台，还可以进行检测，让某个命令只能被op执行。  
这里给出一个简单的示例：  
{% capture sender %} 
```javascript
function myCommandCallback(sender,args){
    if(sender.isPlayer()){
        console.log("玩家在执行命令");
    }else{
        console.log("控制台在执行命令");
    }
    if(sender.isOp()){
        sender.sendMessage("尊敬的OP，命令成功执行");
    }else{
        sender.sendMessage("您不配！");
    }
}
manager.createCommand("mycommand","我的测试命令","myCommandCallback");
```
---NEWTAB--- 
```python
def myCommandCallback(sender,args):
    if sender.isPlayer():
        logger.info(u"玩家在执行命令")
    else:
        logger.info(u"控制台在执行命令")
    if sender.isOp():
        sender.sendMessage(u"尊敬的OP，命令成功执行")
    else:
        sender.sendMessage(u"您不配！")
manager.createCommand(u"mycommand",u"我的测试命令",u"myCommandCallback")
```
---NEWTAB--- 
```lua
function myCommandCallback(sender,args)  
    if(sender:isPlayer()) then
        logger:info("玩家在执行命令")
    else
        logger:info("控制台在执行命令")
    end
    if(sender:isOp()) then
        sender:sendMessage("尊敬的OP，命令成功执行")
    else
        sender:sendMessage("您不配！")
    end
end
manager:createCommand("mycommand","我的测试命令","myCommandCallback")  
```
---NEWTAB--- 
```php
function myCommandCallback($sender,$args){
    if($sender->isPlayer()){
        echo "玩家在执行命令";
    }else{
        echo "控制台在执行命令";
    }
    if($sender->isOp()){
        $sender->sendMessage("尊敬的OP，命令成功执行");
    }else{
        $sender->sendMessage("您不配！");
    }
}
$manager->createCommand("mycommand","我的测试命令","myCommandCallback");
```
{% endcapture %}
{% include tab.html tabId="sender" tabTitles="JavaScript,Python,Lua,PHP" tabContents=sender %}
再次提醒，命令发送者并不是玩家，你可以通过`getName`获取命令发送者的名字，如果是玩家发送的，那么获取到的名字就是玩家的名字，再通过`server`基对象获取玩家对象。  
{% capture player %} 
```javascript
function myCommandCallback(sender,args){
    if(sender.isPlayer()){
        var player = server.getPlayer(sender.getName());
        //player变量是执行命令的玩家
    }
}
manager.createCommand("mycommand","我的测试命令","myCommandCallback");
```
---NEWTAB--- 
```python
def myCommandCallback(sender,args):
    if sender.isPlayer():
        player = server.getPlayer(sender.getName())
        # player变量是执行命令的玩家
manager.createCommand(u"mycommand",u"我的测试命令",u"myCommandCallback")
```
---NEWTAB--- 
```lua
function myCommandCallback(sender,args)  
    if(sender:isPlayer()) then
        player = server:getPlayer(sender:getName())
        -- player变量是执行命令的玩家
    end
end
manager:createCommand("mycommand","我的测试命令","myCommandCallback")  
```
---NEWTAB--- 
```php
function myCommandCallback($sender,$args){
    if($sender->isPlayer()){
        $player = server->getPlayer(sender->getName());
        //player变量是执行命令的玩家
    }
}
$manager->createCommand("mycommand","我的测试命令","myCommandCallback");
```
{% endcapture %}
{% include tab.html tabId="player" tabTitles="JavaScript,Python,Lua,PHP" tabContents=player %}
